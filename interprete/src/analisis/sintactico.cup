package analisis;
// importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;
import abstracto.Instruccion;
import Simbolo.Tipo;
import Simbolo.tipoDato;
import excepciones.Errores;
//instrucciones
import instrucciones.Print;
import instrucciones.Declaracion;
import instrucciones.AsignacionVar;
import instrucciones.If;
import instrucciones.While;
import instrucciones.Break;
import instrucciones.Metodo;
import instrucciones.Start;
import instrucciones.Llamada;
import instrucciones.DeclaracionList;
//expresiones
import expresiones.Nativo;
import expresiones.OperadoresAritmeticos;
import expresiones.Aritmeticas;
import expresiones.OperadoresRelacionales;
import expresiones.Relacionales;
import expresiones.AccesoVar;
import expresiones.AccessList;
parser code
{:
        public LinkedList<Errores> listaErrores = new LinkedList<>();
        scanner s;
        parser(scanner s){this.s = s;};
        public void syntax_error(Symbol s){
        listaErrores.add(new Errores("SINTACTICO", "No se el componente" + s.value, s.left, s.right));
        System.out.println("Error sintactico en la linea " + (s.left) + "y columna " + (s.right) + ". No se esperaba el siguiente componente: " + (s.value));
        }
        public void unrecovered_syntax_error(Symbol s){
             listaErrores.add(new Errores("SINTACTICO", "No se el componente" + s.value, s.left, s.right));
            System.out.println("Error sintactico no recuperable en la linea " + (s.left) + "y columna " + (s.right) + ". No se esperaba el siguiente componente: " + (s.value));
        }
        

:}

action code
{:
:}

//terminales
terminal String CADENA, ENTERO, DECIMAL, ID, INT, DOUBLE, STRING, VAR;
terminal Character CHAR;
terminal FINCADENA, PRINT, PAR1, PAR2, MAS, MENOS, UMENOS, DOSPUNTOS;
terminal IGUAL, EQUALS;
terminal TRUE, FALSE, _if, _else;
terminal _llaveizq, _llaveder, _corabrir, _corcerrar;
terminal _while, _menorq, _mayorq;
terminal _for;
terminal String _break;
terminal VOID, COMA, START, _new, _list;
// no terminales
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion DECLARACION, ASIGNACION;
nonterminal Tipo TIPOS;
nonterminal Instruccion SIF;
nonterminal LinkedList<Instruccion> ELSEIF;
nonterminal Instruccion WHILE;
nonterminal Instruccion BREAK;
nonterminal Instruccion FOR, ACTUALIZAR_FOR;
nonterminal Instruccion METODO;
nonterminal LinkedList<HashMap> PARAMS;
nonterminal Instruccion STARTT;
nonterminal Instruccion LLAMADA;
nonterminal Instruccion DECLARACIONLISTA;
nonterminal LinkedList<Instruccion> PARAMSLLAMADA;
//orden de precedencia final cuando se tenga declarado todos los simbolos en el lexico
//precedence left OR;
//precedence left AND;
//precedence left XOR;
//precedence right NOT;
//precedence left IGUALACION, DIFERENTE, MENORQ, MAYORQ, MENORIGUAL, MAYORIGUAL;
//precedence left SUMA, MENOS;
//precedence left MULTIPLICACION, DIVISION, MODULO;
//precedence nonassoc POTENCIA;
//precedence right UMENOS;

precedence left EQUALS, _menorq, _mayorq;
precedence left MAS;
precedence left MENOS;
precedence right UMENOS;

start with INICIO;

INICIO ::= INSTRUCCIONES:a   {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;
INSTRUCCION ::= PRINT PAR1 EXPRESION:a PAR2 FINCADENA {: RESULT =  new Print(a, aleft, aright);:}
                | DECLARACION:a   {: RESULT = a;  :}
                | ASIGNACION:a    {: RESULT = a; :}
                | SIF:a            {:RESULT = a; :}
                | WHILE:a           {:RESULT = a; :}
                | BREAK:a          {:RESULT = a; :}
                | FOR:a             {: RESULT = a; :}
                | METODO:a         {: RESULT = a; :}
                | STARTT:a         {: RESULT = a; :}
                | LLAMADA:a      {: RESULT = a; :}
                | DECLARACIONLISTA:a {: RESULT = a; :}
                | error FINCADENA
                | error 
;
WHILE ::= _while PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT = new While(a, b, aleft, aright); :}
; 
SIF ::= _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT = new If(a, b, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder _else _llaveizq INSTRUCCIONES:c _llaveder {: RESULT =  new If(a, b, c, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder ELSEIF:c {: RESULT =  new If(a, b, c, null, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder ELSEIF:c _else _llaveizq INSTRUCCIONES:d _llaveder  {: RESULT =  new If(a, b, c, d, aleft, aright); :}
;
ELSEIF ::=  ELSEIF:m _else _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {:RESULT=m; RESULT.add(new If(a, b, aleft, aright));:}
            | _else _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT =  new LinkedList<>(); RESULT.add(new If(a, b, aleft, aright));:}
;

FOR ::= _for PAR1 ASIGNACION:a EXPRESION:b FINCADENA ACTUALIZAR_FOR:c PAR2 _llaveizq INSTRUCCIONES:d _llaveder 
;

ACTUALIZAR_FOR ::= ID:a IGUAL EXPRESION:b {: RESULT = new AsignacionVar(a, b, aleft, aright); :}
; 

BREAK ::= _break:a FINCADENA {: RESULT =  new Break(aleft, aright); :}
; 


DECLARACION ::= VAR  ID:b DOSPUNTOS TIPOS:a IGUAL EXPRESION:c FINCADENA {: RESULT = new Declaracion(b, c, a, aleft, aright); :}
                 | VAR ID:b DOSPUNTOS TIPOS:a FINCADENA
                {: RESULT = new Declaracion(b, null, a, bleft, bright); :}
;   
DECLARACIONLISTA ::= _list _menorq TIPOS:a _mayorq ID:b IGUAL _new _list PAR1 PAR2 FINCADENA
{: RESULT = new DeclaracionList(b, a, aleft, aright); :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION: b FINCADENA {: RESULT = new AsignacionVar(a, b, aleft, aright); :}
;
METODO ::= TIPOS:a ID:b PAR1 PAR2 _llaveizq INSTRUCCIONES:c _llaveder {: RESULT=new Metodo(b, new LinkedList<HashMap>(), c, a, aleft, aright);:}
            | TIPOS:a ID:b PAR1 PARAMS:p PAR2 _llaveizq INSTRUCCIONES:c _llaveder    {: RESULT=new Metodo(b, p,c, a, aleft, aright);:}

[ [1, 2], [3, 4], [5,5], [6,6] ]; 
LISTAVALORES ::= VALORES:a COMA EXPRESION:b
            | EXPRESION:a
;


PARAMS ::= PARAMS:a COMA TIPOS:b ID:c {:
                                   RESULT  = a;
                                   var hm2 = new HashMap<String, Object>();
                                   hm2.put("id",c);
                                   hm2.put("tipo",b);
                                   RESULT.add(hm2); 
                                :}
        |  TIPOS:a ID:b               {: 
                                    
                                    RESULT = new LinkedList<HashMap>();
                                    var hm = new HashMap<String, Object>();
                                    hm.put("id", b);
                                    hm.put("tipo", a);  
                                    RESULT.add(hm);

                                  :}
;

STARTT ::= START ID:a PAR1 PAR2 FINCADENA {: RESULT = new Start(a, new LinkedList<Instruccion>(),aleft, aright); :}
        | START ID:a PAR1 PARAMSLLAMADA:b PAR2 FINCADENA {: RESULT = new Start(a, b, aleft, aright); :}
;
LLAMADA ::= ID:a PAR1 PARAMSLLAMADA:b PAR2 FINCADENA {: RESULT = new Llamada(a, b, aleft, aright);:}
            | ID:a PAR1 PAR2 FINCADENA      {: RESULT = new Llamada(a, new LinkedList<Instruccion>(),aleft, aright); :}
            
;

PARAMSLLAMADA ::= PARAMSLLAMADA:a COMA EXPRESION:b {:  RESULT = a;  
                                                        RESULT.add(b);
                                                    :}
                | EXPRESION:a                       {:
                                                        RESULT = new LinkedList<Instruccion>();
                                                        RESULT.add(a);
                                                    :}
;
TIPOS ::=   INT         {: RESULT = new Tipo(tipoDato.ENTERO);  :}
          | DOUBLE      {: RESULT = new Tipo(tipoDato.DECIMAL);  :}
          | STRING      {: RESULT = new Tipo(tipoDato.CADENA);  :}
          | VOID         {: RESULT = new Tipo(tipoDato.VOID);  :}
;

EXPRESION ::=  MENOS EXPRESION:a           {: RESULT = new Aritmeticas(OperadoresAritmeticos.NEGACION, a, aleft, aright); :} %prec UMENOS
              | EXPRESION:a MAS EXPRESION:b  {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright); :}
              | EXPRESION:a EQUALS EXPRESION:b {:    RESULT = new Relacionales(a, b, OperadoresRelacionales.EQUALS, aleft, aright);    :}
              | EXPRESION:a _menorq EXPRESION:b {:    RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOR, aleft, aright);    :}
              | PAR1 EXPRESION:a PAR2  {: RESULT = a; :}
              | ENTERO:a       {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright);:}   
              | DECIMAL:a   {: RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright);:}
              | CHAR:a {: RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright); :}
              | CADENA:a    {: RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright);:}
              | ID:a            {: RESULT = new AccesoVar(a, aleft, aright);  :}
              | ID:a _corabrir EXPRESION:b _corcerrar {: RESULT = new AccessList(a,b, aleft, aright);  :}
              | TRUE:a        {:   RESULT = new Nativo(true, new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
              | FALSE:a       {:   RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO), aleft, aright );    :}
              
;