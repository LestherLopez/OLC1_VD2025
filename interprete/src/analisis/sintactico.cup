package analisis;
// importaciones
import java_cup.runtime.Symbol;
import java.util.LinkedList;
import abstracto.Instruccion;
import Simbolo.Tipo;
import Simbolo.tipoDato;
//instrucciones
import instrucciones.Print;
import instrucciones.Declaracion;
import instrucciones.AsignacionVar;
import instrucciones.If;
import instrucciones.While;
import instrucciones.Break;
//expresiones
import expresiones.Nativo;
import expresiones.OperadoresAritmeticos;
import expresiones.Aritmeticas;
import expresiones.OperadoresRelacionales;
import expresiones.Relacionales;
import expresiones.AccesoVar;
parser code
{:
        scanner s;
        parser(scanner s){this.s = s;};
        public void syntax_error(Symbol s){
        System.out.println("Error sintactico en la linea " + (s.left) + "y columna " + (s.right) + ". No se esperaba el siguiente componente: " + (s.value));
        }
        public void unrecovered_syntax_error(Symbol s){
            System.out.println("Error sintactico no recuperable en la linea " + (s.left) + "y columna " + (s.right) + ". No se esperaba el siguiente componente: " + (s.value));
        }
        

:}

action code
{:
:}

//terminales
terminal String CADENA, ENTERO, DECIMAL, ID, INT, DOUBLE, STRING, VAR;
terminal Character CHAR;
terminal FINCADENA, PRINT, PAR1, PAR2, MAS, MENOS, UMENOS, DOSPUNTOS;
terminal IGUAL, EQUALS;
terminal TRUE, FALSE, _if, _else;
terminal _llaveizq, _llaveder;
terminal _while, _menorq;
terminal String _break;
// no terminales
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion DECLARACION, ASIGNACION;
nonterminal Tipo TIPOS;
nonterminal Instruccion SIF;
nonterminal LinkedList<Instruccion> ELSEIF;
nonterminal Instruccion WHILE;
nonterminal Instruccion BREAK;
//orden de precedencia final cuando se tenga declarado todos los simbolos en el lexico
//precedence left OR;
//precedence left AND;
//precedence left XOR;
//precedence right NOT;
//precedence left IGUALACION, DIFERENTE, MENORQ, MAYORQ, MENORIGUAL, MAYORIGUAL;
//precedence left SUMA, MENOS;
//precedence left MULTIPLICACION, DIVISION, MODULO;
//precedence nonassoc POTENCIA;
//precedence right UMENOS;

precedence left EQUALS, _menorq;
precedence left MAS;
precedence left MENOS;
precedence right UMENOS;

start with INICIO;

INICIO ::= INSTRUCCIONES:a   {: RESULT = a; :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;
INSTRUCCION ::= PRINT PAR1 EXPRESION:a PAR2 FINCADENA {: RESULT =  new Print(a, aleft, aright);:}
                | DECLARACION:a   {: RESULT = a;  :}
                | ASIGNACION:a    {: RESULT = a; :}
                | SIF:a            {:RESULT = a; :}
                | WHILE:a           {:RESULT = a; :}
                | BREAK:a          {:RESULT = a; :}
;
WHILE ::= _while PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT = new While(a, b, aleft, aright); :}
; 
SIF ::= _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT = new If(a, b, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder _else _llaveizq INSTRUCCIONES:c _llaveder {: RESULT =  new If(a, b, c, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder ELSEIF:c {: RESULT =  new If(a, b, c, null, aleft, aright); :}
        | _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder ELSEIF:c _else _llaveizq INSTRUCCIONES:d _llaveder  {: RESULT =  new If(a, b, c, d, aleft, aright); :}
;
ELSEIF ::=  ELSEIF:m _else _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {:RESULT=m; RESULT.add(new If(a, b, aleft, aright));:}
            | _else _if PAR1 EXPRESION:a PAR2 _llaveizq INSTRUCCIONES:b _llaveder {: RESULT =  new LinkedList<>(); RESULT.add(new If(a, b, aleft, aright));:}
;

BREAK ::= _break:a FINCADENA {: RESULT =  new Break(aleft, aright); :}
; 
DECLARACION ::= VAR  ID:b DOSPUNTOS TIPOS:a IGUAL EXPRESION:c FINCADENA {: RESULT = new Declaracion(b, c, a, aleft, aright); :}
                 | VAR ID:b DOSPUNTOS TIPOS:a FINCADENA
                {: RESULT = new Declaracion(b, null, a, bleft, bright); :}
;   

ASIGNACION ::= ID:a IGUAL EXPRESION: b FINCADENA {: RESULT = new AsignacionVar(a, b, aleft, aright); :}
;

TIPOS ::=   INT         {: RESULT = new Tipo(tipoDato.ENTERO);  :}
          | DOUBLE      {: RESULT = new Tipo(tipoDato.DECIMAL);  :}
          | STRING      {: RESULT = new Tipo(tipoDato.CADENA);  :}
;

EXPRESION ::=  MENOS EXPRESION:a           {: RESULT = new Aritmeticas(OperadoresAritmeticos.NEGACION, a, aleft, aright); :} %prec UMENOS
              | EXPRESION:a MAS EXPRESION:b  {: RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright); :}
              | EXPRESION:a EQUALS EXPRESION:b {:    RESULT = new Relacionales(a, b, OperadoresRelacionales.EQUALS, aleft, aright);    :}
              | EXPRESION:a _menorq EXPRESION:b {:    RESULT = new Relacionales(a, b, OperadoresRelacionales.MENOR, aleft, aright);    :}
              | PAR1 EXPRESION:a PAR2  {: RESULT = a; :}
              | ENTERO:a       {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO), aleft, aright);:}   
              | DECIMAL:a   {: RESULT = new Nativo(new Double(a), new Tipo(tipoDato.DECIMAL), aleft, aright);:}
              | CHAR:a {: RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER), aleft, aright); :}
              | CADENA:a    {: RESULT = new Nativo(a, new Tipo(tipoDato.CADENA), aleft, aright);:}
              | ID:a            {: RESULT = new AccesoVar(a, aleft, aright);  :}
              | TRUE:a        {:   RESULT = new Nativo(true, new Tipo(tipoDato.BOOLEANO), aleft, aright );   :}
              | FALSE:a       {:   RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO), aleft, aright );    :}
             
;